# Copyright 2020 Energinet DataHub A/S
#
# Licensed under the Apache License, Version 2.0 (the "License2");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
name: Streaming Job Deploy (Enrichment and Validation)
on:
  # IMPORTANT: This push trigger has been commented out because the workflow depends on
  # .github/workflows/build-publish-wheel-file.yml and it would thus introduce a race condition
  # to have this workflow triggered automatically.
  # We'll need to eventually solve this problem so we can have this workflow triggered automatically.
  #push:
    #branches:
    #  - main
    #paths:
    #  - source/streaming/geh_stream/**
    #  - build/infrastructure/databricks_streaming_job/**
    #  - build/infrastructure/job_modules/**
    #  - .github/workflows/streaming-job-cd.yml
  workflow_dispatch:
    inputs:
      resource_group_name:
        description: 'Resource Group Name You Want to Use for Deployment'
        required: true
        default: ''
      env_name:
        description: 'Env name used to postfix resources names'
        required: true
        default: ''
      client_id:
        description: 'Service Principal Client (Application) Id'
        required: true
        default: ''
      object_id:
        description: 'Service Principal Object Id'
        required: true
        default: ''
      client_secret:
        description: 'Service Principal Secret'
        required: true
        default: ''

jobs:
  streaming_job_deploy:

    # Name the Job
    name: Deploy databricks cluster and create job
    # Set the type of machine to run on
    runs-on: ubuntu-latest
    environment:
      name: rg-DataHub-D
    env:
      WHEEL_STORAGE_ADDRESS: https://enrgtwheels.blob.core.windows.net/wheels/
      MAIN_PYTHON_FILE: "dbfs:/streaming/enrichment_and_validation.py"

    steps:

      - name: Checkout code
        uses: actions/checkout@v2

      - name: Read Pipeline Configuration
        uses: ./.github/actions/read-pipeline-configuration

      - name: Set Environment Secrets
        run: |
          echo "ARM_TENANT_ID=${{ secrets.TENANT_ID }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_ID=${{ secrets.SPN_ID }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_OBJECT_ID=${{ secrets.SPN_OBJECT_ID }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=${{ secrets.SPN_SECRET }}" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=${{ secrets.SPN_SUBSCRIPTION_ID }}" >> $GITHUB_ENV

      # Run only if workflow started on demand (manually triggered)
      - name: Set Variables from Pipeline Inputs
        uses: ./.github/actions/override_env_settings
        if:   github.event.inputs.resource_group_name

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1.2.1
        with:
          terraform_wrapper: false

      - name: Setup Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.7' # Version range or exact version of a Python version to use, using SemVer's version range syntax
          architecture: 'x64' # optional x64 or x86. Defaults to x64 if not specified

      - name: Azure CLI Install and Login
        uses: ./.github/actions/azure-cli-install-login

      - name: Obtain Databricks Workspace ID and Url
        id: obtain-db-id-url
        uses: ./.github/actions/obtain-databricks-id-url

      - name: Databricks CLI Install And Connect
        uses: ./.github/actions/databricks-cli-install-connect
        with:
          workspace-url: ${{ steps.obtain-db-id-url.outputs.workspace-url }}

      - name: Obtain Keyvault ID and Name
        id: obtain-keyvault-id-name
        uses: ./.github/actions/obtain-keyvault-id-name

      # Download wheel file - step 1 of 4
      - name: Obtain Wheel Version File Name
        id:   wheel-version-file-name
        uses: ./.github/actions/obtain-published-wheel-version-file-name
        
      # Download wheel file - step 2 of 4
      - name: Obtain Wheel Version
        id:   wheel-version
        uses: ./.github/actions/obtain-latest-published-wheel-version
        with:
          published_wheel_version_file_url: "${{ env.WHEEL_STORAGE_ADDRESS }}${{ steps.wheel-version-file-name.outputs.filename }}"

      # Download wheel file - step 3 of 4
      - name: Construct Wheel File Name
        uses: ./.github/actions/construct-wheel-file-name
        with:
          wheel_version: ${{ steps.wheel-version.outputs.version }}
          
      # Download wheel file - step 4 of 4
      - uses: suisei-cn/actions-download-file@v1
        name: Download the Wheel File
        with:
          url: "${{ env.WHEEL_STORAGE_ADDRESS }}${{ env.WHEEL_FILE_NAME }}"
          target: wheels/

      - name: Copy Wheel File to Databricks Workspace
        uses: ./.github/actions/copy-wheel-file-to-databricks

      - name: Copy Job Definition to Databricks File System (DBFS)
        id: copy_main_file_todbfs
        run: |
          dbfs cp --overwrite ./source/streaming/enrichment_and_validation.py ${{ env.MAIN_PYTHON_FILE }}

      - uses: suisei-cn/actions-download-file@v1
        name: Download Custom CosmosDB connector
        with:
          # Temporarily used package. See comments in .devcontainer/spark-defaults.conf.
          url: "https://github.com/FabianMeiswinkel/PrivateNugetPackages/raw/master/azure-cosmosdb-spark_3.0.0_2.12-3.6.2-uber.jar"
          target: cosmosdb_connector/

      - name: Copy Custom CosmosDB connector to DBFS
        id: copy_cosmosdb_connector_todbfs
        run: |
          dbfs cp --overwrite ./cosmosdb_connector/azure-cosmosdb-spark_3.0.0_2.12-3.6.2-uber.jar dbfs:/streaming/cosmosdb-connector.jar

      # Try not to reference TF_VAR variables in pipeline yml files, only values should be set and they should be read in terraform only
      # rather create duplicate ENV pipeline vatiable if needed to separate concerns
      - name: Set TF Vars
        run: |
          echo "TF_VAR_environment=${{ env.ENV_NAME }}" >> $GITHUB_ENV
          echo "TF_VAR_organisation=${{ env.ORGANISATION_NAME }}" >> $GITHUB_ENV
          echo "TF_VAR_resource_group_name=${{ env.RESOURCE_GROUP_NAME }}" >> $GITHUB_ENV
          echo "TF_VAR_storage_account_name=timeseriesdata${{ env.ORGANISATION_NAME }}${{ env.ENV_NAME }}" >> $GITHUB_ENV
          echo "TF_VAR_keyvault_id=${{ steps.obtain-keyvault-id-name.outputs.keyvault-id }}" >> $GITHUB_ENV
          echo "TF_VAR_databricks_id=${{ steps.obtain-db-id-url.outputs.workspace-id }}" >> $GITHUB_ENV
          echo "TF_VAR_python_main_file=${{ env.MAIN_PYTHON_FILE}}" >> $GITHUB_ENV

      - name: Configure Terraform Backend
        uses: ./.github/actions/configure-terraform-backend
        with:
          backend-file-path: "./build/infrastructure/databricks_streaming_job/backend.tf"
          resource-group-name: "${{ env.RESOURCE_GROUP_NAME }}"
          storage-account-name: "tfstateendk${{ env.ENV_NAME }}"

      # Create streaming job
      - name: Terraform Databricks Init
        working-directory: ./build/infrastructure/databricks_streaming_job
        run: terraform init

      - name: Terraform Plan
        working-directory: ./build/infrastructure/databricks_streaming_job
        run: terraform plan

      # resource in command must match with resource name in main.tf
      # after feature: https://github.com/databrickslabs/terraform-provider-databricks/issues/389
      # is available this should be changed and job should not be recreated on each run - taint to be removed
      - name: Terraform Databricks Apply
        id: terraform-apply
        working-directory: ./build/infrastructure/databricks_streaming_job
        run: |
          terraform apply -no-color -auto-approve
          terraform taint module.streaming_job.databricks_job.streaming_job
          echo "::set-output name=job-id::$(terraform output databricks_job_id)"
        continue-on-error: false

      - name: Databricks CLI Run the Job
        id: run-job
        uses: ./.github/actions/databricks-cli-run-jobs
        with:
          job-ids: ${{ steps.terraform-apply.outputs.job-id }}

      - name: Check Job Status
        working-directory: ./build
        run: |
          pip install configargparse
          pip install requests
          python -u job_status_check.py --job-run-ids  ${{ steps.run-job.outputs.job-run-ids }} --retries 2 --databricks-url 'https://${{ steps.obtain-db-id-url.outputs.workspace-url }}' --token ${{ env.DATABRICKS_AAD_TOKEN }}
